"""
soorma dev - Start local development environment.

Implements the "Infra in Docker, Code on Host" pattern:
- Infrastructure (Registry, NATS) runs in Docker containers
- User's agent code runs natively on the host with hot reload
- Environment variables injected for connectivity
"""

import os
import sys
import time
import subprocess
import shutil
from pathlib import Path
from typing import Optional, List

import typer

# Docker Compose template for local development infrastructure
DOCKER_COMPOSE_TEMPLATE = '''# Soorma Local Development Stack
# Generated by: soorma dev
# Infrastructure runs in Docker, your agent runs on the host

services:
  # NATS - Event Bus
  nats:
    image: nats:2.10-alpine
    container_name: soorma-nats
    ports:
      - "${NATS_PORT:-4222}:4222"      # Client connections
      - "${NATS_HTTP_PORT:-8222}:8222" # HTTP monitoring
    command: ["--jetstream", "--http_port", "8222"]
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8222/healthz"]
      interval: 5s
      timeout: 3s
      retries: 3

  # Registry Service - Agent & Event Registration
  # Uses local image if available, falls back to public when published
  registry:
    image: ${REGISTRY_IMAGE:-registry-service:latest}
    container_name: soorma-registry
    ports:
      - "${REGISTRY_PORT:-8081}:8000"
    environment:
      - DATABASE_URL=sqlite+aiosqlite:////tmp/registry.db
      - SYNC_DATABASE_URL=sqlite:////tmp/registry.db
      - NATS_URL=nats://nats:4222
    depends_on:
      nats:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # Event Service - PubSub Proxy (SSE + REST)
  event-service:
    image: ${EVENT_SERVICE_IMAGE:-event-service:latest}
    container_name: soorma-event-service
    ports:
      - "${EVENT_SERVICE_PORT:-8082}:8082"
    environment:
      - EVENT_ADAPTER=nats
      - NATS_URL=nats://nats:4222
      - DEBUG=false
    depends_on:
      nats:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8082/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 5s

networks:
  default:
    name: soorma-dev
'''


def check_docker() -> str:
    """Check if Docker is available and running. Returns compose command."""
    # Check if docker command exists
    if not shutil.which("docker"):
        typer.echo("‚ùå Error: Docker is not installed.", err=True)
        typer.echo("Please install Docker: https://docs.docker.com/get-docker/", err=True)
        raise typer.Exit(1)
    
    # Check if Docker daemon is running
    try:
        result = subprocess.run(
            ["docker", "info"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode != 0:
            typer.echo("‚ùå Error: Docker daemon is not running.", err=True)
            typer.echo("Please start Docker and try again.", err=True)
            raise typer.Exit(1)
    except subprocess.TimeoutExpired:
        typer.echo("‚ùå Error: Docker is not responding.", err=True)
        raise typer.Exit(1)
    
    # Check if docker compose is available
    try:
        result = subprocess.run(
            ["docker", "compose", "version"],
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode != 0:
            if shutil.which("docker-compose"):
                return "docker-compose"
            typer.echo("‚ùå Error: Docker Compose is not available.", err=True)
            raise typer.Exit(1)
    except subprocess.TimeoutExpired:
        typer.echo("‚ùå Error: Docker Compose is not responding.", err=True)
        raise typer.Exit(1)
    
    return "docker compose"


# Service definitions for the dev stack
# Each service has: local_image, public_image, dockerfile (relative to soorma-core root)
# SOORMA_CORE_PATH should point to soorma-core root (soorma-platform/core/ in monorepo)
SERVICE_DEFINITIONS = {
    "registry": {
        "local_image": "registry-service:latest",
        "public_image": "ghcr.io/soorma-ai/registry-service:latest",
        "dockerfile": "services/registry/Dockerfile",
        "name": "Registry Service",
    },
    "event-service": {
        "local_image": "event-service:latest",
        "public_image": "ghcr.io/soorma-ai/event-service:latest",
        "dockerfile": "services/event-service/Dockerfile",
        "name": "Event Service",
    },
    # Future services can be added here:
    # "tracker": {
    #     "local_image": "tracker-service:latest",
    #     "public_image": "ghcr.io/soorma-ai/tracker-service:latest",
    #     "dockerfile": "services/tracker/Dockerfile",
    #     "name": "State Tracker",
    # },
}


def check_service_image(service_key: str) -> Optional[str]:
    """
    Check for available service image.
    
    Returns the image name to use, or None if not found.
    Priority:
    1. Local image
    2. Public image (ghcr.io)
    """
    service = SERVICE_DEFINITIONS.get(service_key)
    if not service:
        return None
    
    # Check for local image
    result = subprocess.run(
        ["docker", "images", "-q", service["local_image"]],
        capture_output=True,
        text=True,
    )
    if result.returncode == 0 and result.stdout.strip():
        return service["local_image"]
    
    # Check for public image (will fail if not published yet)
    result = subprocess.run(
        ["docker", "manifest", "inspect", service["public_image"]],
        capture_output=True,
        text=True,
    )
    if result.returncode == 0:
        return service["public_image"]
    
    return None


def find_soorma_core_root() -> Optional[Path]:
    """
    Find the soorma-core repository root.
    
    Searches SOORMA_CORE_PATH env var and common locations.
    The root should have services/ and libs/ directories directly.
    
    For soorma-platform monorepo users, set:
        export SOORMA_CORE_PATH=/path/to/soorma-platform/core
    """
    search_paths = []
    
    # Check SOORMA_CORE_PATH env var first (highest priority)
    env_path = os.environ.get("SOORMA_CORE_PATH")
    if env_path:
        search_paths.append(Path(env_path))
    
    # Common locations for standalone soorma-core repo
    search_paths.extend([
        Path.home() / "ws" / "github" / "soorma-ai" / "soorma-core",
        Path.home() / "code" / "soorma-core",
        Path.home() / "projects" / "soorma-core",
        Path.home() / "soorma-core",
        Path.cwd().parent / "soorma-core",
        Path.cwd().parent.parent / "soorma-core",
    ])
    
    for path in search_paths:
        # Verify it's the right repo by checking for services/ directory
        if (path / "services").exists() and (path / "libs").exists():
            return path
    
    return None


def build_service_image(service_key: str, soorma_core_root: Path) -> bool:
    """
    Build a service image from source.
    
    Returns True if build succeeded.
    """
    service = SERVICE_DEFINITIONS.get(service_key)
    if not service:
        return False
    
    dockerfile = soorma_core_root / service["dockerfile"]
    if not dockerfile.exists():
        typer.echo(f"   ‚ö†Ô∏è  Dockerfile not found: {service['dockerfile']}", err=True)
        return False
    
    typer.echo(f"   Building {service['name']}...")
    
    result = subprocess.run(
        ["docker", "build", "-f", service["dockerfile"], "-t", service["local_image"], "."],
        cwd=soorma_core_root,
        capture_output=False,  # Show build output
    )
    
    return result.returncode == 0


def build_all_services(soorma_core_root: Path) -> dict:
    """
    Build all service images from source.
    
    Returns dict of {service_key: success_bool}.
    """
    results = {}
    for service_key in SERVICE_DEFINITIONS:
        results[service_key] = build_service_image(service_key, soorma_core_root)
    return results


def get_soorma_dir() -> Path:
    """Get or create the .soorma directory in the current project."""
    soorma_dir = Path.cwd() / ".soorma"
    soorma_dir.mkdir(exist_ok=True)
    return soorma_dir


def get_compose_cmd(compose_cmd: str, compose_file: Path) -> List[str]:
    """Build the base docker compose command."""
    if " " in compose_cmd:
        base_cmd = compose_cmd.split()
    else:
        base_cmd = [compose_cmd]
    base_cmd.extend(["-f", str(compose_file)])
    return base_cmd


def find_agent_entry_point() -> Optional[Path]:
    """
    Find the agent entry point in the current project.
    
    Looks for (in order):
    1. soorma.yaml config with entry point
    2. agent.py in package directory
    3. main.py
    4. app.py
    """
    cwd = Path.cwd()
    
    # Check for soorma.yaml config
    config_file = cwd / "soorma.yaml"
    if config_file.exists():
        try:
            import yaml
            with open(config_file) as f:
                config = yaml.safe_load(f)
                if config and "entry" in config:
                    entry = cwd / config["entry"]
                    if entry.exists():
                        return entry
        except ImportError:
            pass  # yaml not installed, skip config
        except Exception:
            pass
    
    # Look for package with agent.py
    for item in cwd.iterdir():
        if item.is_dir() and not item.name.startswith((".", "_")):
            agent_file = item / "agent.py"
            if agent_file.exists():
                return agent_file
    
    # Fallback to common entry points
    for name in ["agent.py", "main.py", "app.py"]:
        entry = cwd / name
        if entry.exists():
            return entry
    
    return None


def wait_for_infrastructure(registry_port: int, timeout: int = 60) -> bool:
    """Wait for infrastructure to be healthy."""
    import urllib.request
    import urllib.error
    
    start = time.time()
    registry_url = f"http://localhost:{registry_port}/health"
    
    while time.time() - start < timeout:
        try:
            req = urllib.request.Request(registry_url, method="GET")
            with urllib.request.urlopen(req, timeout=2) as resp:
                if resp.status == 200:
                    return True
        except Exception:
            # Any error means the service isn't ready yet
            pass
        time.sleep(1)
    
    return False


class AgentRunner:
    """
    Runs the user's agent code with hot reload support.
    
    Watches for file changes and restarts the agent process.
    """
    
    def __init__(
        self,
        entry_point: Path,
        registry_url: str,
        event_service_url: str,
        nats_url: str,
        watch: bool = True,
    ):
        self.entry_point = entry_point
        self.registry_url = registry_url
        self.event_service_url = event_service_url
        self.nats_url = nats_url
        self.watch = watch
        self.process: Optional[subprocess.Popen] = None
        self.running = False
        self._file_mtimes: dict = {}
    
    def _get_env(self) -> dict:
        """Get environment variables for the agent process."""
        env = os.environ.copy()
        env.update({
            "SOORMA_REGISTRY_URL": self.registry_url,
            "SOORMA_EVENT_SERVICE_URL": self.event_service_url,
            "SOORMA_BUS_URL": self.nats_url,
            "SOORMA_NATS_URL": self.nats_url,
            "SOORMA_DEV_MODE": "true",
        })
        return env
    
    def _get_watch_files(self) -> List[Path]:
        """Get list of Python files to watch for changes."""
        files = []
        cwd = Path.cwd()
        
        # Watch all .py files in the project
        for py_file in cwd.rglob("*.py"):
            # Skip hidden dirs, venv, __pycache__, .soorma
            parts = py_file.parts
            if any(p.startswith(".") or p == "__pycache__" or p in ("venv", ".venv", "node_modules") for p in parts):
                continue
            files.append(py_file)
        
        return files
    
    def _check_for_changes(self) -> bool:
        """Check if any watched files have changed."""
        changed = False
        
        for filepath in self._get_watch_files():
            try:
                mtime = filepath.stat().st_mtime
                if filepath in self._file_mtimes:
                    if mtime > self._file_mtimes[filepath]:
                        typer.echo(f"   üìù Changed: {filepath.relative_to(Path.cwd())}")
                        changed = True
                self._file_mtimes[filepath] = mtime
            except OSError:
                pass
        
        return changed
    
    def _init_file_mtimes(self):
        """Initialize file modification times."""
        self._file_mtimes = {}
        for filepath in self._get_watch_files():
            try:
                self._file_mtimes[filepath] = filepath.stat().st_mtime
            except OSError:
                pass
    
    def start_agent(self):
        """Start the agent process."""
        if self.process and self.process.poll() is None:
            self.stop_agent()
        
        typer.echo(f"   üöÄ Starting agent: {self.entry_point.name}")
        
        self.process = subprocess.Popen(
            [sys.executable, str(self.entry_point)],
            env=self._get_env(),
            cwd=Path.cwd(),
        )
    
    def stop_agent(self):
        """Stop the agent process."""
        if self.process:
            typer.echo("   ‚èπÔ∏è  Stopping agent...")
            self.process.terminate()
            try:
                self.process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                self.process.kill()
                self.process.wait()
            self.process = None
    
    def restart_agent(self):
        """Restart the agent process (hot reload)."""
        typer.echo("")
        typer.echo("   üîÑ Hot reload triggered!")
        self.stop_agent()
        time.sleep(0.5)  # Brief pause for cleanup
        self.start_agent()
    
    def run(self):
        """Run the agent with optional hot reload."""
        self.running = True
        self._init_file_mtimes()
        self.start_agent()
        
        if not self.watch:
            # Just wait for the process
            try:
                self.process.wait()
            except KeyboardInterrupt:
                self.stop_agent()
            return
        
        # Watch for changes
        typer.echo("   üëÄ Watching for file changes...")
        typer.echo("")
        
        try:
            while self.running:
                # Check if process crashed
                if self.process and self.process.poll() is not None:
                    exit_code = self.process.returncode
                    if exit_code != 0:
                        typer.echo(f"   ‚ö†Ô∏è  Agent exited with code {exit_code}")
                        typer.echo("   Waiting for file changes to restart...")
                
                # Check for file changes
                if self._check_for_changes():
                    self.restart_agent()
                
                time.sleep(1)  # Poll interval
                
        except KeyboardInterrupt:
            pass
        finally:
            self.stop_agent()


def dev_stack(
    detach: bool = typer.Option(
        False,
        "--detach", "-d",
        help="Run infrastructure in background only (don't start agent).",
    ),
    no_watch: bool = typer.Option(
        False,
        "--no-watch",
        help="Disable hot reload (don't watch for file changes).",
    ),
    stop: bool = typer.Option(
        False,
        "--stop",
        help="Stop the running development stack.",
    ),
    status: bool = typer.Option(
        False,
        "--status",
        help="Show status of the development stack.",
    ),
    logs: bool = typer.Option(
        False,
        "--logs",
        help="Show logs from the infrastructure containers.",
    ),
    infra_only: bool = typer.Option(
        False,
        "--infra-only",
        help="Only start infrastructure, don't run the agent.",
    ),
    registry_port: int = typer.Option(
        8081,
        "--registry-port",
        help="Port for the Registry service.",
    ),
    nats_port: int = typer.Option(
        4222,
        "--nats-port",
        help="Port for NATS client connections.",
    ),
    event_service_port: int = typer.Option(
        8082,
        "--event-service-port",
        help="Port for the Event Service.",
    ),
    build: bool = typer.Option(
        False,
        "--build",
        help="Build service images from local soorma-core source before starting.",
    ),
):
    """
    Start the local Soorma development environment.
    
    This command implements the "Infra in Docker, Code on Host" pattern:
    
    \b
    ‚Ä¢ Infrastructure (Registry, NATS) runs in Docker containers
    ‚Ä¢ Your agent code runs natively on your machine
    ‚Ä¢ File changes trigger automatic hot reload
    ‚Ä¢ No docker build cycle - instant iteration!
    
    \b
    Usage:
      soorma dev           # Start infra + run agent with hot reload
      soorma dev --build   # Build images first, then start
      soorma dev --detach  # Start infra only (background)
      soorma dev --stop    # Stop everything
    """
    # Check Docker availability
    compose_cmd = check_docker()
    
    # Get .soorma directory and compose file
    soorma_dir = get_soorma_dir()
    compose_file = soorma_dir / "docker-compose.yml"
    env_file = soorma_dir / ".env"
    
    # Write docker-compose.yml
    compose_file.write_text(DOCKER_COMPOSE_TEMPLATE)
    
    # Check for service images (unless just stopping/status/logs)
    service_images = {}
    if not stop and not status and not logs:
        # If --build flag, build all services first
        if build:
            typer.echo("üî® Building service images...")
            soorma_core_root = find_soorma_core_root()
            if not soorma_core_root:
                typer.echo("‚ùå Could not find soorma-core repository.", err=True)
                typer.echo("")
                typer.echo("Set SOORMA_CORE_PATH to the repo location:", err=True)
                typer.echo("  export SOORMA_CORE_PATH=/path/to/soorma-core", err=True)
                typer.echo("  soorma dev --build", err=True)
                raise typer.Exit(1)
            
            typer.echo(f"   Found soorma-core at: {soorma_core_root}")
            build_results = build_all_services(soorma_core_root)
            
            failed = [k for k, v in build_results.items() if not v]
            if failed:
                typer.echo(f"‚ùå Failed to build: {', '.join(failed)}", err=True)
                raise typer.Exit(1)
            
            typer.echo("   ‚úì All images built successfully!")
            typer.echo("")
        
        # Check for required service images
        missing_services = []
        for service_key, service_def in SERVICE_DEFINITIONS.items():
            image = check_service_image(service_key)
            if image:
                service_images[service_key] = image
            else:
                missing_services.append((service_key, service_def))
        
        if missing_services:
            typer.echo("‚ùå Required service images not found:", err=True)
            for key, svc in missing_services:
                typer.echo(f"   ‚Ä¢ {svc['name']} ({svc['local_image']})", err=True)
            typer.echo("")
            typer.echo("Options:", err=True)
            typer.echo("")
            typer.echo("  1. Auto-build from source (if you have soorma-core cloned):", err=True)
            typer.echo("     soorma dev --build", err=True)
            typer.echo("")
            typer.echo("  2. Set SOORMA_CORE_PATH and build:", err=True)
            typer.echo("     export SOORMA_CORE_PATH=/path/to/soorma-core", err=True)
            typer.echo("     soorma dev --build", err=True)
            typer.echo("")
            typer.echo("  3. Manual build from soorma-core root:", err=True)
            typer.echo("     cd /path/to/soorma-core", err=True)
            for key, svc in missing_services:
                typer.echo(f"     docker build -f {svc['dockerfile']} -t {svc['local_image']} .", err=True)
            typer.echo("")
            typer.echo("Note: Public images will be available at ghcr.io/soorma-ai/*", err=True)
            typer.echo("once the platform is released.", err=True)
            raise typer.Exit(1)
    
    # Get service images for env file
    registry_image = service_images.get("registry", "registry-service:latest")
    event_service_image = service_images.get("event-service", "event-service:latest")
    
    # Write .env file with custom ports and service images
    env_content = f"""# Soorma Local Development Environment
NATS_PORT={nats_port}
NATS_HTTP_PORT=8222
REGISTRY_PORT={registry_port}
REGISTRY_IMAGE={registry_image or 'registry-service:latest'}
EVENT_SERVICE_PORT={event_service_port}
EVENT_SERVICE_IMAGE={event_service_image or 'event-service:latest'}
"""
    env_file.write_text(env_content)
    
    # Build base compose command
    base_cmd = get_compose_cmd(compose_cmd, compose_file)
    
    # Handle --stop
    if stop:
        typer.echo("üõë Stopping Soorma development stack...")
        result = subprocess.run(base_cmd + ["down"], cwd=soorma_dir)
        if result.returncode == 0:
            typer.echo("‚úì Stack stopped.")
        raise typer.Exit(result.returncode)
    
    # Handle --status
    if status:
        typer.echo("üìä Soorma development stack status:")
        typer.echo("")
        subprocess.run(base_cmd + ["ps"], cwd=soorma_dir)
        raise typer.Exit(0)
    
    # Handle --logs
    if logs:
        typer.echo("üìã Infrastructure logs (Ctrl+C to exit):")
        subprocess.run(base_cmd + ["logs", "-f"], cwd=soorma_dir)
        raise typer.Exit(0)
    
    # Find agent entry point (unless infra-only or detach)
    entry_point = None
    if not infra_only and not detach:
        entry_point = find_agent_entry_point()
        if not entry_point:
            typer.echo("‚ö†Ô∏è  No agent entry point found.", err=True)
            typer.echo("   Looking for: agent.py, main.py, or app.py", err=True)
            typer.echo("   Use --infra-only to start infrastructure without an agent.", err=True)
            typer.echo("")
            typer.echo("   Tip: Run 'soorma init my-agent' to create a new project.", err=True)
            raise typer.Exit(1)
    
    # Print banner
    typer.echo("")
    typer.echo("‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ")
    typer.echo("‚îÇ           üöÄ Soorma Development Environment             ‚îÇ")
    typer.echo("‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ")
    typer.echo("")
    
    # Start infrastructure
    typer.echo("üì¶ Starting infrastructure (Docker)...")
    typer.echo(f"   Registry:      http://localhost:{registry_port}")
    typer.echo(f"   Event Service: http://localhost:{event_service_port}")
    typer.echo(f"   NATS:          nats://localhost:{nats_port}")
    typer.echo("")
    
    # Pull images (quiet mode)
    subprocess.run(
        base_cmd + ["pull", "-q"],
        cwd=soorma_dir,
        capture_output=True,
    )
    
    # Start containers in detached mode
    up_result = subprocess.run(
        base_cmd + ["up", "-d"],
        cwd=soorma_dir,
        capture_output=True,
        text=True,
    )
    
    if up_result.returncode != 0:
        typer.echo("‚ùå Failed to start infrastructure:", err=True)
        typer.echo(up_result.stderr, err=True)
        raise typer.Exit(1)
    
    # Wait for infrastructure to be healthy
    typer.echo("   ‚è≥ Waiting for services to be ready...")
    if not wait_for_infrastructure(registry_port, timeout=60):
        typer.echo("‚ùå Infrastructure failed to start. Check logs:", err=True)
        typer.echo(f"   soorma dev --logs", err=True)
        raise typer.Exit(1)
    
    typer.echo("   ‚úì Infrastructure ready!")
    typer.echo("")
    
    # If detach or infra-only, we're done
    if detach or infra_only:
        typer.echo("‚úì Infrastructure running in background.")
        typer.echo("")
        typer.echo("Useful commands:")
        typer.echo("  soorma dev --status  # Check status")
        typer.echo("  soorma dev --logs    # View logs")
        typer.echo("  soorma dev --stop    # Stop stack")
        typer.echo("")
        typer.echo("To run your agent:")
        typer.echo(f"  export SOORMA_REGISTRY_URL=http://localhost:{registry_port}")
        typer.echo(f"  export SOORMA_EVENT_SERVICE_URL=http://localhost:{event_service_port}")
        typer.echo(f"  export SOORMA_NATS_URL=nats://localhost:{nats_port}")
        typer.echo("  python agent.py")
        raise typer.Exit(0)
    
    # Run the agent with hot reload
    typer.echo("ü§ñ Starting agent (native Python process)...")
    typer.echo(f"   Entry point: {entry_point.relative_to(Path.cwd())}")
    if not no_watch:
        typer.echo("   Hot reload: enabled")
    typer.echo("")
    typer.echo("‚îÄ" * 50)
    typer.echo("Press Ctrl+C to stop")
    typer.echo("‚îÄ" * 50)
    typer.echo("")
    
    # Create and run the agent
    runner = AgentRunner(
        entry_point=entry_point,
        registry_url=f"http://localhost:{registry_port}",
        event_service_url=f"http://localhost:{event_service_port}",
        nats_url=f"nats://localhost:{nats_port}",
        watch=not no_watch,
    )
    
    try:
        runner.run()
    except KeyboardInterrupt:
        pass
    finally:
        typer.echo("")
        typer.echo("üõë Stopping development environment...")
        
        # Stop infrastructure
        subprocess.run(
            base_cmd + ["down"],
            cwd=soorma_dir,
            capture_output=True,
        )
        typer.echo("‚úì Done.")
