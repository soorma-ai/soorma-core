"""
soorma dev - Start local development environment.

Implements the "Infra in Docker" pattern:
- Infrastructure (Registry, Event Service, Memory Service, NATS, PostgreSQL) runs in Docker containers
- Developers run their agent code separately with injected environment variables
"""

import os
import sys
import time
import subprocess
import shutil
from pathlib import Path
from typing import Optional, List

import typer

# Docker Compose template for local development infrastructure
DOCKER_COMPOSE_TEMPLATE = '''# Soorma Local Development Stack
# Generated by: soorma dev
# Infrastructure runs in Docker, your agent runs on the host

services:
  # PostgreSQL with pgvector - Database for Memory & Registry Services
  postgres:
    image: pgvector/pgvector:pg16
    container_name: soorma-postgres
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    environment:
      - POSTGRES_USER=soorma
      - POSTGRES_PASSWORD=soorma
      - POSTGRES_DB=postgres
      - POSTGRES_INITDB_ARGS=--encoding=UTF8
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./postgres-init:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U soorma -d postgres"]
      interval: 5s
      timeout: 3s
      retries: 5

  # NATS - Event Bus
  nats:
    image: nats:2.10-alpine
    container_name: soorma-nats
    ports:
      - "${NATS_PORT:-4222}:4222"      # Client connections
      - "${NATS_HTTP_PORT:-8222}:8222" # HTTP monitoring
    command: ["--jetstream", "--http_port", "8222"]
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8222/healthz"]
      interval: 5s
      timeout: 3s
      retries: 3

  # Registry Service - Agent & Event Registration
  # Uses local image if available, falls back to public when published
  registry:
    image: ${REGISTRY_IMAGE:-registry-service:latest}
    container_name: soorma-registry
    ports:
      - "${REGISTRY_PORT:-8081}:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://soorma:soorma@postgres:5432/registry
      - SYNC_DATABASE_URL=postgresql+psycopg2://soorma:soorma@postgres:5432/registry
      - NATS_URL=nats://nats:4222
    depends_on:
      postgres:
        condition: service_healthy
      nats:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # Event Service - PubSub Proxy (SSE + REST)
  event-service:
    image: ${EVENT_SERVICE_IMAGE:-event-service:latest}
    container_name: soorma-event-service
    ports:
      - "${EVENT_SERVICE_PORT:-8082}:8082"
    environment:
      - EVENT_ADAPTER=nats
      - NATS_URL=nats://nats:4222
      - DEBUG=false
    depends_on:
      nats:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8082/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 5s

  # Memory Service - Persistent Memory Layer (CoALA)
  memory-service:
    image: ${MEMORY_SERVICE_IMAGE:-memory-service:latest}
    container_name: soorma-memory
    ports:
      - "${MEMORY_SERVICE_PORT:-8083}:8002"
    environment:
      - DATABASE_URL=postgresql+asyncpg://soorma:soorma@postgres:5432/memory
      - SYNC_DATABASE_URL=postgresql+psycopg2://soorma:soorma@postgres:5432/memory
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - IS_LOCAL_TESTING=true
      - IS_PROD=false
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8002/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 15s

volumes:
  postgres-data:
    name: soorma-postgres-data

networks:
  default:
    name: soorma-dev
'''

# PostgreSQL initialization script
# Creates pgvector extension and separate databases for each service
POSTGRES_INIT_SQL = '''-- Initialize Soorma PostgreSQL Databases
-- Creates separate databases for each service and enables pgvector extension

-- Create databases for each service (only if they don't exist)
SELECT 'CREATE DATABASE registry' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'registry')\\gexec
SELECT 'CREATE DATABASE memory' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'memory')\\gexec

-- Connect to registry database and enable pgvector
\\c registry
CREATE EXTENSION IF NOT EXISTS vector;

-- Connect to memory database and enable pgvector
\\c memory
CREATE EXTENSION IF NOT EXISTS vector;
'''


def check_docker() -> str:
    """Check if Docker is available and running. Returns compose command."""
    # Check if docker command exists
    if not shutil.which("docker"):
        typer.echo("âŒ Error: Docker is not installed.", err=True)
        typer.echo("Please install Docker: https://docs.docker.com/get-docker/", err=True)
        raise typer.Exit(1)
    
    # Check if Docker daemon is running
    try:
        result = subprocess.run(
            ["docker", "info"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode != 0:
            typer.echo("âŒ Error: Docker daemon is not running.", err=True)
            typer.echo("Please start Docker and try again.", err=True)
            raise typer.Exit(1)
    except subprocess.TimeoutExpired:
        typer.echo("âŒ Error: Docker is not responding.", err=True)
        raise typer.Exit(1)
    
    # Check if docker compose is available
    try:
        result = subprocess.run(
            ["docker", "compose", "version"],
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode != 0:
            if shutil.which("docker-compose"):
                return "docker-compose"
            typer.echo("âŒ Error: Docker Compose is not available.", err=True)
            raise typer.Exit(1)
    except subprocess.TimeoutExpired:
        typer.echo("âŒ Error: Docker Compose is not responding.", err=True)
        raise typer.Exit(1)
    
    return "docker compose"


# Service definitions for the dev stack
# Each service has: local_image, public_image, dockerfile (relative to soorma-core root)
# SOORMA_CORE_PATH should point to soorma-core root (soorma-platform/core/ in monorepo)
SERVICE_DEFINITIONS = {
    "registry": {
        "local_image": "registry-service:latest",
        "public_image": "ghcr.io/soorma-ai/registry-service:latest",
        "dockerfile": "services/registry/Dockerfile",
        "name": "Registry Service",
    },
    "event-service": {
        "local_image": "event-service:latest",
        "public_image": "ghcr.io/soorma-ai/event-service:latest",
        "dockerfile": "services/event-service/Dockerfile",
        "name": "Event Service",
    },
    "memory-service": {
        "local_image": "memory-service:latest",
        "public_image": "ghcr.io/soorma-ai/memory-service:latest",
        "dockerfile": "services/memory/Dockerfile",
        "name": "Memory Service",
    },
    # Future services can be added here:
    # "tracker": {
    #     "local_image": "tracker-service:latest",
    #     "public_image": "ghcr.io/soorma-ai/tracker-service:latest",
    #     "dockerfile": "services/tracker/Dockerfile",
    #     "name": "State Tracker",
    # },
}


def check_service_image(service_key: str) -> Optional[str]:
    """
    Check for available service image.
    
    Returns the image name to use, or None if not found.
    Priority:
    1. Local image
    2. Public image (ghcr.io)
    """
    service = SERVICE_DEFINITIONS.get(service_key)
    if not service:
        return None
    
    # Check for local image
    result = subprocess.run(
        ["docker", "images", "-q", service["local_image"]],
        capture_output=True,
        text=True,
    )
    if result.returncode == 0 and result.stdout.strip():
        return service["local_image"]
    
    # Check for public image (will fail if not published yet)
    result = subprocess.run(
        ["docker", "manifest", "inspect", service["public_image"]],
        capture_output=True,
        text=True,
    )
    if result.returncode == 0:
        return service["public_image"]
    
    return None


def find_soorma_core_root() -> Optional[Path]:
    """
    Find the soorma-core repository root.
    
    Searches SOORMA_CORE_PATH env var and common locations.
    The root should have services/ and libs/ directories directly.
    
    For soorma-platform monorepo users, set:
        export SOORMA_CORE_PATH=/path/to/soorma-platform/core
    """
    search_paths = []
    
    # Check SOORMA_CORE_PATH env var first (highest priority)
    env_path = os.environ.get("SOORMA_CORE_PATH")
    if env_path:
        search_paths.append(Path(env_path))
    
    # Common locations for standalone soorma-core repo
    search_paths.extend([
        Path.home() / "ws" / "github" / "soorma-ai" / "soorma-core",
        Path.home() / "code" / "soorma-core",
        Path.home() / "projects" / "soorma-core",
        Path.home() / "soorma-core",
        Path.cwd().parent / "soorma-core",
        Path.cwd().parent.parent / "soorma-core",
    ])
    
    for path in search_paths:
        # Verify it's the right repo by checking for services/ directory
        if (path / "services").exists() and (path / "libs").exists():
            return path
    
    return None


def build_service_image(service_key: str, soorma_core_root: Path) -> bool:
    """
    Build a service image from source.
    
    Returns True if build succeeded.
    """
    service = SERVICE_DEFINITIONS.get(service_key)
    if not service:
        return False
    
    dockerfile = soorma_core_root / service["dockerfile"]
    if not dockerfile.exists():
        typer.echo(f"   âš ï¸  Dockerfile not found: {service['dockerfile']}", err=True)
        return False
    
    typer.echo(f"   Building {service['name']}...")
    
    result = subprocess.run(
        ["docker", "build", "-f", service["dockerfile"], "-t", service["local_image"], "."],
        cwd=soorma_core_root,
        capture_output=False,  # Show build output
    )
    
    return result.returncode == 0


def build_all_services(soorma_core_root: Path) -> dict:
    """
    Build all service images from source.
    
    Returns dict of {service_key: success_bool}.
    """
    results = {}
    for service_key in SERVICE_DEFINITIONS:
        results[service_key] = build_service_image(service_key, soorma_core_root)
    return results


def get_soorma_dir() -> Path:
    """Get or create the .soorma directory in the current project."""
    soorma_dir = Path.cwd() / ".soorma"
    soorma_dir.mkdir(exist_ok=True)
    return soorma_dir


def get_compose_cmd(compose_cmd: str, compose_file: Path) -> List[str]:
    """Build the base docker compose command."""
    if " " in compose_cmd:
        base_cmd = compose_cmd.split()
    else:
        base_cmd = [compose_cmd]
    base_cmd.extend(["-f", str(compose_file)])
    return base_cmd


def wait_for_infrastructure(registry_port: int, timeout: int = 60) -> bool:
    """Wait for infrastructure to be healthy."""
    import urllib.request
    import urllib.error
    
    start = time.time()
    registry_url = f"http://localhost:{registry_port}/health"
    
    while time.time() - start < timeout:
        try:
            req = urllib.request.Request(registry_url, method="GET")
            with urllib.request.urlopen(req, timeout=2) as resp:
                if resp.status == 200:
                    return True
        except Exception:
            # Any error means the service isn't ready yet
            pass
        time.sleep(1)
    
    return False


def dev_stack(
    start: bool = typer.Option(
        False,
        "--start",
        help="Start the infrastructure stack (default behavior).",
    ),
    stop: bool = typer.Option(
        False,
        "--stop",
        help="Stop the running development stack.",
    ),
    status: bool = typer.Option(
        False,
        "--status",
        help="Show status of the development stack.",
    ),
    logs: bool = typer.Option(
        False,
        "--logs",
        help="Show logs from the infrastructure containers.",
    ),
    registry_port: int = typer.Option(
        8081,
        "--registry-port",
        help="Port for the Registry service.",
    ),
    nats_port: int = typer.Option(
        4222,
        "--nats-port",
        help="Port for NATS client connections.",
    ),
    event_service_port: int = typer.Option(
        8082,
        "--event-service-port",
        help="Port for the Event Service.",
    ),
    memory_service_port: int = typer.Option(
        8083,
        "--memory-service-port",
        help="Port for the Memory Service.",
    ),
    postgres_port: int = typer.Option(
        5432,
        "--postgres-port",
        help="Port for PostgreSQL database.",
    ),
    build: bool = typer.Option(
        False,
        "--build",
        help="Build service images from local soorma-core source before starting.",
    ),
):
    """
    Start the local Soorma development environment.
    
    This command manages Docker infrastructure for Soorma services:
    
    \b
    â€¢ Registry Service - Agent & event registration
    â€¢ Event Service - PubSub proxy (SSE + REST)
    â€¢ Memory Service - Persistent memory layer (CoALA)
    â€¢ NATS - Event bus with JetStream
    â€¢ PostgreSQL - Database with pgvector
    
    \b
    Usage:
      soorma dev           # Start infrastructure (default)
      soorma dev --start   # Explicitly start infrastructure
      soorma dev --build   # Build images first, then start
      soorma dev --status  # Check status
      soorma dev --logs    # View logs
      soorma dev --stop    # Stop everything
    
    After starting, run your agent separately with these environment variables:
      SOORMA_REGISTRY_URL=http://localhost:8081
      SOORMA_EVENT_SERVICE_URL=http://localhost:8082
      SOORMA_MEMORY_SERVICE_URL=http://localhost:8083
      SOORMA_NATS_URL=nats://localhost:4222
    """
    # Check Docker availability
    compose_cmd = check_docker()
    
    # Get .soorma directory and compose file
    soorma_dir = get_soorma_dir()
    compose_file = soorma_dir / "docker-compose.yml"
    env_file = soorma_dir / ".env"
    
    # Write docker-compose.yml
    compose_file.write_text(DOCKER_COMPOSE_TEMPLATE)
    
    # Write PostgreSQL initialization script
    postgres_init_dir = soorma_dir / "postgres-init"
    postgres_init_dir.mkdir(exist_ok=True)
    init_sql = postgres_init_dir / "01-init.sql"
    init_sql.write_text(POSTGRES_INIT_SQL)
    
    # Check for service images (unless just stopping/status/logs)
    service_images = {}
    if not stop and not status and not logs:
        # If --build flag, build all services first
        if build:
            typer.echo("ðŸ”¨ Building service images...")
            soorma_core_root = find_soorma_core_root()
            if not soorma_core_root:
                typer.echo("âŒ Could not find soorma-core repository.", err=True)
                typer.echo("")
                typer.echo("Set SOORMA_CORE_PATH to the repo location:", err=True)
                typer.echo("  export SOORMA_CORE_PATH=/path/to/soorma-core", err=True)
                typer.echo("  soorma dev --build", err=True)
                raise typer.Exit(1)
            
            typer.echo(f"   Found soorma-core at: {soorma_core_root}")
            build_results = build_all_services(soorma_core_root)
            
            failed = [k for k, v in build_results.items() if not v]
            if failed:
                typer.echo(f"âŒ Failed to build: {', '.join(failed)}", err=True)
                raise typer.Exit(1)
            
            typer.echo("   âœ“ All images built successfully!")
            typer.echo("")
        
        # Check for required service images
        missing_services = []
        for service_key, service_def in SERVICE_DEFINITIONS.items():
            image = check_service_image(service_key)
            if image:
                service_images[service_key] = image
            else:
                missing_services.append((service_key, service_def))
        
        if missing_services:
            typer.echo("âŒ Required service images not found:", err=True)
            for key, svc in missing_services:
                typer.echo(f"   â€¢ {svc['name']} ({svc['local_image']})", err=True)
            typer.echo("")
            typer.echo("Options:", err=True)
            typer.echo("")
            typer.echo("  1. Auto-build from source (if you have soorma-core cloned):", err=True)
            typer.echo("     soorma dev --build", err=True)
            typer.echo("")
            typer.echo("  2. Set SOORMA_CORE_PATH and build:", err=True)
            typer.echo("     export SOORMA_CORE_PATH=/path/to/soorma-core", err=True)
            typer.echo("     soorma dev --build", err=True)
            typer.echo("")
            typer.echo("  3. Manual build from soorma-core root:", err=True)
            typer.echo("     cd /path/to/soorma-core", err=True)
            for key, svc in missing_services:
                typer.echo(f"     docker build -f {svc['dockerfile']} -t {svc['local_image']} .", err=True)
            typer.echo("")
            typer.echo("Note: Public images will be available at ghcr.io/soorma-ai/*", err=True)
            typer.echo("once the platform is released.", err=True)
            raise typer.Exit(1)
    
    # Get service images for env file
    registry_image = service_images.get("registry", "registry-service:latest")
    event_service_image = service_images.get("event-service", "event-service:latest")
    memory_service_image = service_images.get("memory-service", "memory-service:latest")
    
    # Get OpenAI API key from environment
    openai_api_key = os.environ.get("OPENAI_API_KEY", "")
    
    # Write .env file with custom ports and service images
    env_content = f"""# Soorma Local Development Environment
NATS_PORT={nats_port}
NATS_HTTP_PORT=8222
REGISTRY_PORT={registry_port}
REGISTRY_IMAGE={registry_image or 'registry-service:latest'}
EVENT_SERVICE_PORT={event_service_port}
EVENT_SERVICE_IMAGE={event_service_image or 'event-service:latest'}
MEMORY_SERVICE_PORT={memory_service_port}
MEMORY_SERVICE_IMAGE={memory_service_image or 'memory-service:latest'}
POSTGRES_PORT={postgres_port}
OPENAI_API_KEY={openai_api_key}
"""
    env_file.write_text(env_content)
    
    # Build base compose command
    base_cmd = get_compose_cmd(compose_cmd, compose_file)
    
    # Handle --stop
    if stop:
        typer.echo("ðŸ›‘ Stopping Soorma development stack...")
        result = subprocess.run(base_cmd + ["down"], cwd=soorma_dir)
        if result.returncode == 0:
            typer.echo("âœ“ Stack stopped.")
        raise typer.Exit(result.returncode)
    
    # Handle --status
    if status:
        typer.echo("ðŸ“Š Soorma development stack status:")
        typer.echo("")
        subprocess.run(base_cmd + ["ps"], cwd=soorma_dir)
        raise typer.Exit(0)
    
    # Handle --logs
    if logs:
        typer.echo("ðŸ“‹ Infrastructure logs (Ctrl+C to exit):")
        subprocess.run(base_cmd + ["logs", "-f"], cwd=soorma_dir)
        raise typer.Exit(0)
    
    # Default behavior is to start infrastructure (--start is explicit but not required)
    # Print banner
    typer.echo("")
    typer.echo("â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®")
    typer.echo("â”‚           ðŸš€ Soorma Development Environment             â”‚")
    typer.echo("â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯")
    typer.echo("")
    
    # Start infrastructure
    typer.echo("ðŸ“¦ Starting infrastructure (Docker)...")
    typer.echo(f"   Registry:      http://localhost:{registry_port}")
    typer.echo(f"   Event Service: http://localhost:{event_service_port}")
    typer.echo(f"   Memory Service: http://localhost:{memory_service_port}")
    typer.echo(f"   NATS:          nats://localhost:{nats_port}")
    typer.echo(f"   PostgreSQL:    postgresql://localhost:{postgres_port}")
    typer.echo("")
    
    # Pull images (quiet mode)
    subprocess.run(
        base_cmd + ["pull", "-q"],
        cwd=soorma_dir,
        capture_output=True,
    )
    
    # Start containers in detached mode
    up_result = subprocess.run(
        base_cmd + ["up", "-d"],
        cwd=soorma_dir,
        capture_output=True,
        text=True,
    )
    
    if up_result.returncode != 0:
        typer.echo("âŒ Failed to start infrastructure:", err=True)
        typer.echo(up_result.stderr, err=True)
        raise typer.Exit(1)
    
    # Wait for infrastructure to be healthy
    typer.echo("   â³ Waiting for services to be ready...")
    if not wait_for_infrastructure(registry_port, timeout=60):
        typer.echo("âŒ Infrastructure failed to start. Check logs:", err=True)
        typer.echo(f"   soorma dev --logs", err=True)
        raise typer.Exit(1)
    
    typer.echo("   âœ“ Infrastructure ready!")
    typer.echo("")
    
    # Infrastructure is started - provide instructions for running agents
    typer.echo("âœ“ Infrastructure running in background.")
    typer.echo("")
    typer.echo("Useful commands:")
    typer.echo("  soorma dev --status  # Check status")
    typer.echo("  soorma dev --logs    # View logs")
    typer.echo("  soorma dev --stop    # Stop stack")
    typer.echo("")
    typer.echo("To run your agent, set these environment variables:")
    typer.echo(f"  export SOORMA_REGISTRY_URL=http://localhost:{registry_port}")
    typer.echo(f"  export SOORMA_EVENT_SERVICE_URL=http://localhost:{event_service_port}")
    typer.echo(f"  export SOORMA_MEMORY_SERVICE_URL=http://localhost:{memory_service_port}")
    typer.echo(f"  export SOORMA_NATS_URL=nats://localhost:{nats_port}")
    typer.echo("  python agent.py")
    raise typer.Exit(0)
